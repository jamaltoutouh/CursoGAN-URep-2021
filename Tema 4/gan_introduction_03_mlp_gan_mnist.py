"""
Author: Jamal Toutouh (www.jamal.es)

It contains the code to show an example about using GANs.
The GAN is used to generate samples of MNIST dataset (handwriten digits).

It requires TorchVision: !pip install torch torchvision

Spanish: Ejemplo en el que se entrena una GAN para generar imágenes del dataset MNIST (dígitos manuscritos).

Original file is located at
    https://colab.research.google.com/drive/1FVdtHJK3vertgUVIMlfoM4E7tg0YWuIg
"""

import torch
import torchvision #Required --> to install it run "!pip install torch torchvision"
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import DataLoader
from torchvision import datasets
from torchvision import transforms
from torchvision.utils import save_image
import numpy as np
import datetime
import os, sys
from matplotlib.pyplot import imshow, imsave
# %matplotlib inline


"""Tareas previas:
- Darle nombre al modelo
- Configurar el entorno de ejecución para que funcione tanto si existe **GPU** como si no (se ejecutará en CPU)
"""

MODEL_NAME = 'SimpleGAN'
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")


"""Función auxiliar para crear 100 imágenes sintéticas generadas por el Generador *G*"""

# Function to create 100 fake samples generated by the Generator
def get_sample_image(G, z_size):
    z = torch.randn(100, z_size).to(DEVICE)
    y_hat = G(z).view(100, 28, 28) # (100, 28, 28)
    result = y_hat.cpu().data.numpy()
    img = np.zeros([280, 280])
    for j in range(10):
        img[j*28:(j+1)*28] = np.concatenate([x for x in result[j*10:(j+1)*10]], axis=-1)
    return img


"""Clase para definir un Discriminador simple, arquitectura MLP con tres capas"""

class Discriminator(nn.Module):
    def __init__(self, input_size=784, output_size=1):
        super(Discriminator, self).__init__()
        self.layer = nn.Sequential(
            nn.Linear(input_size, 512),
            nn.LeakyReLU(0.2),
            nn.Linear(512, 256),
            nn.LeakyReLU(0.2),
            nn.Linear(256, output_size),
            nn.Sigmoid(),
        )
    
    def forward(self, x):
        y_ = x.view(x.size(0), -1)
        y_ = self.layer(y_)
        return y_


"""Clase para definir un Generador simple, arquitectura MLP cinco capas"""

class Generator(nn.Module):
    def __init__(self, input_size=100, output_size=784):
        super(Generator, self).__init__()
        self.layer = nn.Sequential(
            nn.Linear(input_size, 128),
            nn.LeakyReLU(0.2),
            nn.Linear(128, 256),
            nn.BatchNorm1d(256),
            nn.LeakyReLU(0.2),
            nn.Linear(256, 512),
            nn.BatchNorm1d(512),
            nn.LeakyReLU(0.2),
            nn.Linear(512, 1024),
            nn.BatchNorm1d(1024),
            nn.LeakyReLU(0.2),
            nn.Linear(1024, output_size),
            nn.Tanh()
        )
        
    def forward(self, x):
        y_ = self.layer(x)
        y_ = y_.view(x.size(0), 1, 28, 28)
        return y_


"""Definimos las variables que instancian el Discriminador y el Generador"""

discriminator = Discriminator().to(DEVICE)    # Discriminator ANN

z_size = 100   # Size of the latent space vector
generator = Generator(z_size).to(DEVICE)  # Generator ANN


"""Obtener datos (MNIST)"""

transform = transforms.Compose([transforms.ToTensor(),
                                transforms.Normalize(mean=[0.5],
                                std=[0.5])]
)

mnist = datasets.MNIST(root='../data/', train=True, transform=transform, download=True)
batch_size = 64
data_loader = DataLoader(dataset=mnist, batch_size=batch_size, shuffle=True, drop_last=True)


"""Preparación del entrenamiento"""

criterion = nn.BCELoss()
discriminator_optimizer = torch.optim.Adam(discriminator.parameters(), lr=0.0002, betas=(0.5, 0.999))
generator_optimizer = torch.optim.Adam(generator.parameters(), lr=0.0002, betas=(0.5, 0.999))
max_epoch = 50 
step = 0
n_critic = 1 # Steps to train the discriminator before to train the generator
D_labels = torch.ones(batch_size, 1).to(DEVICE) # Discriminator Label to real
D_fakes = torch.zeros(batch_size, 1).to(DEVICE) # Discriminator Label to fake
if not os.path.exists('samples'):
    os.makedirs('samples')

for epoch in range(max_epoch):
    for idx, (images, _) in enumerate(data_loader):
        # Discrimiantor training
        x = images.to(DEVICE)
        x_outputs = discriminator(x)
        discriminator_x_loss = criterion(x_outputs, D_labels)

        z = torch.randn(batch_size, z_size).to(DEVICE)
        z_outputs = discriminator(generator(z))
        discriminator_z_loss = criterion(z_outputs, D_fakes)
        
        discriminator_loss = discriminator_x_loss + discriminator_z_loss
        
        discriminator.zero_grad()
        discriminator_loss.backward()
        discriminator_optimizer.step()

        if step % n_critic == 0:
            # Generator training
            z = torch.randn(batch_size, z_size).to(DEVICE)
            z_outputs = discriminator(generator(z))
            generator_loss = criterion(z_outputs, D_labels)

            generator.zero_grad()
            generator_loss.backward()
            generator_optimizer.step()
        
        if step % 500 == 0:
            print('Epoch: {}/{}, Step: {}, Discriminator Loss: {}, Generator Loss: {}'.format(epoch, max_epoch, step, discriminator_loss.item(), generator_loss.item()))
        
        if step % 1000 == 0:
            generator.eval()
            img = get_sample_image(generator, z_size)
            imsave('samples/{}_step{}.jpg'.format(MODEL_NAME, str(step).zfill(3)), img, cmap='gray')
            generator.train()
        step += 1


"""**Visualización** de resultado"""

generator.eval()
imshow(get_sample_image(generator, z_size), cmap='gray')


"""Salvar los parámetros encontrados"""

torch.save(discriminator.state_dict(), 'D.pkl')
torch.save(generator.state_dict(), 'G.pkl')

# Commented out IPython magic to ensure Python compatibility.
# %ls samples/


"""Análisis de la evolución de la calidad de soluciones"""

import matplotlib.pyplot as plt
import matplotlib.image as mpimg
img = mpimg.imread('samples/SimpleGAN_step1000.jpg')
imgplot = plt.imshow(img)
plt.show()
img = mpimg.imread('samples/SimpleGAN_step10000.jpg')
imgplot = plt.imshow(img)
plt.show()
img = mpimg.imread('samples/SimpleGAN_step23000.jpg')
imgplot = plt.imshow(img)
plt.show()

img = mpimg.imread('samples/SimpleGAN_step46000.jpg')
imgplot = plt.imshow(img)
plt.show()